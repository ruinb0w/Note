# 创建对象

## 通过一个已有对象来构造

`Object.create(originalObj)`

该方法会返回一个以originalObj为原型的对象

## 构造函数

```js
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}
// 通过new关键字等于是创建了一个新的对象, 然后这个新的对象调用了构造函数, 然后这个构造函数再给这个新的对象添加属性
var xiaoming = new Student(小明);
// 通过上面的代码即可创建一个xiaoming对象,有name属性和hello方法
```

**重点**

1. 实例对象的`__proto__`属性就是构造函数的`prototype`属性

2. 实例对象`__proto__`属性中的属性可以直接访问, 

   例如`xiaoming.__proto__.constructor`可以写为`xiaoming.constructor`

3. 通过构造函数创建的对象还会有`constructor`属性指向构造函数`Student`

4. 每次new都会新建一个对象并赋予这个对象属性或方法所以同样的方法会被复制多次, 造成内存浪费, 可以直接在Student的原型链上添加方法.

   ```js
   function Student(name) {
       this.name = name;
   }
   Student.prototype.hello = function(){
       alert('Hello, ' + this.name + '!');
   }
   ```

> 按照约定，构造函数首字母应当大写，而普通函数首字母应当小写

在构造函数中设置某些属性为默认值的技巧

```
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}
```

## class关键字

```js
class ClassName(){
	//conscructor 用于构造实例的属性
    constructor(proto){
        this.param = param;
    }
    
    // 下面直接写方法, 方法均会被共享
    sharedFunction(){
        
    }
}
```

在进行继承时可以通过

```js
class Son extends Father {
    constructor(param1, param2) {
        super(param1); // 这里的super会调用Father的constructor
        this.param2 = param2;
    }
    
    sharedFunction() {
    }
}
```

# 原型

## 原型链

实例对象调用属性或方法时会现在实例对象自己的属性中查找, 找不到则会通过原型链进行查找